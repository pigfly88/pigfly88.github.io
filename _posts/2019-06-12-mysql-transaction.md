---
layout: post
title:  MySQL的事务
categories: mysql
---

假设A要转100块给B，会涉及到以下操作：

1. 检查A的余额是否>=100
2. A的余额减掉100
3. B的余额加100

现在假设在执行到第2步的时候数据库崩溃了，那么A可能白白损失掉100块。这个问题就引出了一个解决方案：事务。

事务就是将一组操作打包看成一个整体，要么都成功，要么都失败。它具有以下特点：

- 原子性：要么都成功，要么都失败。InnoDB通过undolog保证rollback的时候能找到之前的数据
- 一致性：事务前后，数据总额应该匹配
- 隔离性：事务与事务之间对于数据改变的可见性，隔离级别有：读未提交、读已提交、可重复读、串行，默认是RR，因为相比于RC，InnoDB的RR性能更加好
- 持久性：事务提交以后，数据的改变是永久的。InnoDB通过redolog保证已经commit的数据一定不会丢失

InnoDB是通过事务日志来保证事务的持久性的。我们知道InnoDB在更新数据的时候，并不是马上修改磁盘里的真实数据，因为这样会设计到大量的随机I/O，而是先更新内存，然后写事务日志（redo log），这个日志是写到缓冲区里面的，由于它是写到缓冲区并且是顺序写的，所以性能很好，最后会在合适的时机把事务日志刷新到磁盘，这个时机可以通过```innodb_flush_log_at_trx_commit```来控制：

- 0：事务提交后，每隔一秒，将事务日志从缓冲区刷到日志文件中，并且把日志文件刷新到磁盘上。性能最好，但是可能会丢失一秒的数据。
- 1：事务提交后，马上把事务日志从缓冲区写到日志文件中，并且把日志文件刷新到磁盘上。保证数据不丢失。
- 2：事务提交后，马上把事务日志从缓冲区写到日志文件中，每隔一秒，刷新一次日志文件，但不一定刷新到磁盘上，取决于操作系统的调度。等于是在前面两个选项之间做了折中。

redo log保证了持久性，如果数据更新已经写入日志文件，即使数据还没有真正更新到磁盘上，数据库崩溃重启后，会根据redo log来做恢复。那么原子性如何来保证呢？如果有一个操作失败了是要做回滚的，答案是通过undo log。