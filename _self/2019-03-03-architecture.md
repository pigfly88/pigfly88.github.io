---
layout: post
category: "工具"
title:  "从0开始学架构笔记"
---

## 什么是架构
软件架构指软件系统的顶层结构，**架构设计的主要目的是为了解决软件系统复杂度带来的问题。**

## 复杂度来源

### 高性能

- 单机

    计算机内部复杂度最关键的地方就是操作系统，操作系统和性能最相关的就是进程和线程。操作系统发展到现在，如果我们要完成一个高性能的软件系统，需要考虑如多进程、多线程、进程间通信、多线程并发等。

- 集群
    - 任务分配
        ![集群](/images/cluster.png)

        服务器从一台变成两台，需要增加一个任务分配器，这个分配器可能是硬件网络设备（F5、交换机等），可能是软件网络设备（LVS），也可能是负载均衡软件（Nginx、HAProxy）。

        任务分配器和真正的业务服务器之间有连接和交互（即图中任务分配器到业务服务器的连接线），需要选择合适的连接方式，并且对连接进行管理。例如，连接建立、连接检测、连接中断后如何处理等。

        任务分配器需要增加分配算法。例如，是采用轮询算法，还是按权重分配，又或者按照负载进行分配。

        假设任务分配器也面临瓶颈，也需要扩展为多台机器，架构是这样的：
        ![集群-2](/images/cluster-2.png)
        用户分配常见的方法包括 DNS 轮询、智能 DNS、CDN（Content Delivery Network，内容分发网络）、GSLB 设备（Global Server Load Balance，全局负载均衡）等。

    - 任务分解
        当业务越来越复杂，单台的效率还是很低，即使通过任务分配的方式作用也不大，为了继续提升性能，需要做任务分解。
        ![集群-3](/images/cluster-3.png)

### 高可用

高可用的意思就是无中断地对外提供服务。单台机器肯定是达不到的，要实现高可用，手段跟高性能一样，也是通过增加机器来达到目的。
- 计算高可用

    这里的“计算”指的是业务的逻辑处理。计算有一个特点就是无论在哪台机器上进行计算，同样的算法和输入数据，产出的结果都是一样的。复杂度跟高性能类似，任务分配器的分配算法有所不同。例如，常见的双机算法有主备、主主，主备方案又可以细分为冷备、温备、热备。

- 存储高可用

    需要注意同步数据有延迟带来的问题。

### 可扩展
可扩展性指系统为了应对将来需求变化而提供的一种扩展能力，当有新的需求出现时，系统不需要或者仅需要少量修改就可以支持，无须整个系统重构或者重建。

第一种应对变化的常见方案是将“变化”封装在一个“变化层”，将不变的部分封装在一个独立的“稳定层”。

## 架构设计的三原则
- 合适原则
- 简单原则
- 演化原则

### 应对接口级的故障

接口级故障的典型表现就是系统并没有宕机，网络也没有中断，但业务却出现问题了。例如，业务响应缓慢、大量访问超时、大量访问出现异常（给用户弹出提示“无法连接数据库”），这类问题的主要原因在于系统压力太大、负载太高，导致无法快速处理业务请求，由此引发更多的后续问题。例如，最常见的数据库慢查询将数据库的服务器资源耗尽，导致读写超时，业务读写数据库时要么无法连接数据库、要么超时，最终用户看到的现象就是访问很慢，一会访问抛出异常，一会访问又是正常结果。

导致接口级故障的原因一般有下面几种：
- 内部原因：程序 bug 导致死循环，某个接口导致数据库慢查询，程序逻辑不完善导致耗尽内存等。
- 外部原因：黑客攻击、促销或者抢购引入了超出平时几倍甚至几十倍的用户，第三方系统大量请求，第三方系统响应缓慢等。

解决接口级故障的核心思想和异地多活基本类似：优先保证核心业务和优先保证绝大部分用户。

降级：当服务器负载太高，导致访问很慢等情况的时候，可以采取降级的方案，保证核心业务可用，其他服务暂停来避免占用太多资源。

熔断：当依赖的外部接口响应很慢的时候，立即返回错误或者做一个简单的展示，不再访问外部接口。

限流：1.基于请求量限流：限制总量、限制某个时间段内的请求量。2.基于资源限流：服务器资源（内存、CPU）达到某个阈值

排队：超过阈值则进入排队系统，由于排队需要临时缓存大量的业务请求，单个系统内部无法缓存这么多数据，一般情况下，排队需要用独立的系统去实现，例如使用 Kafka 这类消息队列来缓存用户请求。


## 读写分离

通过主从同步，主机负责读写，从机复杂读。读写分离通过将读请求分摊到不同的节点，来缓解查询压力，适合读多写少的场景。

读写分离会引出两个问题：

- 主从同步的延迟，有以下几种解决方法：
1. 先查缓存；
1. 写操作之后的读操作一定读主机；
1. 关键业务都读主机（注册登录、下单支付）；
1. 读从机失败后再读一次主机

- 读写分配机制，实现方法：
1. 代码封装，目前主流框架都支持读写分离配置；
1. 中间件（mycat）

## 分库分表

读写分离主要是分摊了读的压力，但是没有分散存储压力，假如单表数据量过亿了，那势必会影响查询速度，又或者是单台机器已经装不下了，那么这时候就要考虑做分库分表了。

可以按照业务模块来分，比如用户、商品、订单，分别放到三台机器上去，但是分库会带来下面几个问题：
1. 跨库查询
1. 事务问题
1. 